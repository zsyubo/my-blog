# # 变量
在c++中，局部变量及初始化可以做到随时定义、初始化。
## ## 新定义方式
```c++
int i{ 5 };
int i = { 5 };
// 数组可以这样定义
int a[]{ 11,12,35 };
```
有意思的地方
```c++
// 程序正常执行，但是 `.5f`会被系统截断。
int  ac = 3.5f
// 直接编译失败
int ac {3.5f}
```

# # auto 变量的自动类型推断
可以在变量声明的时候根据变量的初始值的类型自动为此变量选择匹配的类型。当然啦，自动推断是发生在`编译期间`,所以既然要推断，`声明时就要赋予初始值`，可能编译时慢一点，但是好处是`运行时不会造成程序性能降低`。
```c++
 auto bb = true;
 auto cc { 1 };
```

# # 引用
可以理解为：为变量启另一个名字(`别名`)，一般用&符号表示。起完别名后 ，这别名和变量可以看做是同一变量。`定义引用的时候必须初始化`,同时要与别引用的类型相同。底层其实并不是占的同一块内存。`引用不能修改指向`。
```c++
 int value = 110;
// 注意这不是取地址，是引用。
 int &ref = value;
// 和普通变量一样使用
 cout << ref << endl;

// 指针
int *p= &value;
*p=30;
```
引用是指针的弱化版，更安全。  一个引用占用一个指针的大小 。指针的汇编代码和引用一样的。

一般用于参数传递过程中，直接修改变量值。

```c++
int main()
{
int a = 15; 
 int b = 61;
 // 非方法传参则会影响原值。
 func(a, b);
 cout << "a:" << a << "b:" << b << endl; // 4,5
 int &a1 = a;
 int &b1 = b;
 a1 = 99;
 b1 = 88;
 cout << "a:" << a << "b:" << b << endl; // 99,88
}

void func(int &a, int &b) {
// 在函数值中修改引用值，对原值有影响。
 a = 4;
 b = 5;
}
```
当然也可以用指针，不过要麻烦一些。

> 引用是一个指向其它对象的常量指针，它保存着所指对象的存储地址。并且使用的时候会自动解引用，而不需要像使用指针一样显式提领。

## const 与 引用