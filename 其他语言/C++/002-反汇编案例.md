> X86 Debug 环境。 

# sizeof

`sizeof`在C语言的保留字，也可以认为是一种(单目)运算符。`可以获取某个数据类型所占用空间的字节数`。

```c++
	std::cout << sizeof(int) << std::endl;
	getChar();
```

`sizeof()`

```assembly
6A 04                push        4  
```

 这里可以到，`sizeof`直接在编译就处理了。 

​	`getChar();`

```assembly
E8 6A F7 FF FF       call        getChar (0D310B4h)  
```

方法底层就是一个`Call`。

# if-else和switch9

## if-else

```c++
	int  a = 5;
	if (a == 0) {
		printf("0");
	}else if (a == 1) {
		printf("1");
	}else {
		printf("other");
	}
```

其汇编代码为

```assembly
// int a = 5;
00D918CD  mov         dword ptr [a],5  
// cmp = compare,也就是 判断 a ==0?
00D918D4  cmp         dword ptr [a],0  
// jne = jump not equal。也就是不相等时跳转到0D97BCC
00D918D8  jne         main+49h (0D918E9h)  
// 压入 string
00D918DA  push        offset string "0" (0D97BCCh) 
// 调用打印函数 
00D918DF  call        _printf (0D9139Dh)  
00D918E4  add         esp,4  
// jmp是无条件跳转 执行完成跳转到 098195F,也就是程序的末尾
00D918E7  jmp         main+6Bh (0D9190Bh) 
// 判断是否等于1 
00D918E9  cmp         dword ptr [a],1  
00D918ED  jne         main+5Eh (0D918FEh)  
00D918EF  push        offset string "1" (0D97BD0h)  
00D918F4  call        _printf (0D9139Dh)  
00D918F9  add         esp,4  
00D918FC  jmp         main+6Bh (0D9190Bh)  
// else {}的情况
00D918FE  push        offset string "other" (0D97CD0h)  
00D91903  call        _printf (0D9139Dh)  
00D91908  add         esp,4 
// 堆栈平衡
00D9190B  xor         eax,eax  
00D9190D  pop         edi  
00D9190E  pop         esi  
00D9190F  pop         ebx  
00D91910  add         esp,0CCh  
00D91916  cmp         ebp,esp  
00D91918  call        __RTC_CheckEsp (0D9122Bh)  
00D9191D  mov         esp,ebp  
00D9191F  pop         ebp  
00D91920  ret  
```

从汇编代码可以看出，当`if-else`在执行时，如果当前条件不相等，则会跳到下一个比较语句，所以如果 `a>1`的情况，这时候会先和`0、1`相比，这样在极端情况下，其实就多浪费了几条汇编语句，所以在使用`if-else`时，精良在多命中的条件写在前面。

## switch

```c++
switch (a) {
	case 0:
		printf("s 0");
		break;
	case 1:
		printf("s 1");
		break;
	case 2:
		printf("s 2");
		break;
	default:
		printf("s other");
	}
```

这里需要注意的是，如果条件太少，编译器可能会优化为类似`if-else`的情况，具体个数看具体编译器。

````assembly
// int a =5
00824ED8  mov         dword ptr [a],5  
// 下面一堆都是计算 该跳转到哪
//     这部有撒意思？ 
00824EDF  mov         eax,dword ptr [a]  
00824EE2  mov         dword ptr [ebp-0D0h],eax 
//     将临时变量和6进行比较
00824EE8  cmp         dword ptr [ebp-0D0h],6  
//     如果大于5(也就是case中的最大值)，就跳到 default的情况。
00824EEF  ja          $LN10+0Fh (0824F67h)  
//     计算下标。
00824EF1  mov         ecx,dword ptr [ebp-0D0h]  
//     这而可以看做类似访问数组，每一个case是一个数组值, 而ecx就是数组下标。然后计算地址值，然后去对应地址值取跳转地址。
00824EF7  jmp         dword ptr [ecx*4+824F8Ch]  
// 824F8C 为内存中的跳转表头部。  *4是因为相差4个字节(地址为4字节)。很巧妙。

// 一个case语句
$LN4:
00824EFE  push        offset string "s 0" (0827BCCh)  
00824F03  call        _printf (082139Dh)  
00824F08  add         esp,4  
00824F0B  jmp         $LN10+1Ch (0824F74h)  

00824F58  push        offset string "s 6" (0827BE4h)  
00824F5D  call        _printf (082139Dh)  
00824F62  add         esp,4  
00824F65  jmp         $LN10+1Ch (0824F74h)  
// default的情况
00824F67  push        offset string "s other" (0827CD0h)  
00824F6C  call        _printf (082139Dh)
00824F71  add         esp,4 

// 跳转地址表。。
0x00824F8C  fe 4e 82 00  ?N?.
0x00824F90  0d 4f 82 00  .O?.
0x00824F94  1c 4f 82 00  .O?.
0x00824F98  2b 4f 82 00  +O?.
0x00824F9C  3a 4f 82 00  :O?.
0x00824FA0  49 4f 82 00  IO?.
0x00824FA4  58 4f 82 00  XO?.
0x00824FA8  cc cc cc cc  ????

// 计算机是小端模式 fe 4e 82 00 实际读取数据为：00 82 4e fe
````

从汇编代码看出，`switch`与`if-else`最大的不同是，`switch`是会先计算跳转位置，计算完成后，直接跳转到对应的`case`语句直接执行，不用像`if-else`那样需要一个条件一个条件判断。

**PS**

以上是`case`数据是顺序的情况。同时，当`case`是从非0数开始时，会有一句`012F4EEE  sub         ecx,1 `，为 `ecx-1`。

**非连续时**

todo

**跨度大**

如果跨度非常大，就类似于`if-else`。