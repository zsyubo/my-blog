# sizeof

`sizeof`在C语言的保留字，也可以认为是一种(单目)运算符。`可以获取某个数据类型所占用空间的字节数`。

```c++
	std::cout << sizeof(int) << std::endl;
	getChar();
```

`sizeof()`

```
6A 04                push        4  
```

 这里可以到，`sizeof`直接在编译就处理了。 

​	`getChar();`

```
E8 6A F7 FF FF       call        getChar (0D310B4h)  
```

方法底层就是一个`Call`。

# if-else和switch

## if-else

```c++
	int  a = 5;
	if (a == 0) {
		printf("0");
	}else if (a == 1) {
		printf("1");
	}else {
		printf("other");
	}
```

其汇编代码为

```assembly
// int a = 5;
00D918CD  mov         dword ptr [a],5  
// cmp = compare,也就是 判断 a ==0?
00D918D4  cmp         dword ptr [a],0  
// jne = jump not equal。也就是不相等时跳转到0D97BCC
00D918D8  jne         main+49h (0D918E9h)  
// 压入 string
00D918DA  push        offset string "0" (0D97BCCh) 
// 调用打印函数 
00D918DF  call        _printf (0D9139Dh)  
00D918E4  add         esp,4  
// jmp是无条件跳转 执行完成跳转到 098195F,也就是程序的末尾
00D918E7  jmp         main+6Bh (0D9190Bh) 
// 判断是否等于1 
00D918E9  cmp         dword ptr [a],1  
00D918ED  jne         main+5Eh (0D918FEh)  
00D918EF  push        offset string "1" (0D97BD0h)  
00D918F4  call        _printf (0D9139Dh)  
00D918F9  add         esp,4  
00D918FC  jmp         main+6Bh (0D9190Bh)  
// else {}的情况
00D918FE  push        offset string "other" (0D97CD0h)  
00D91903  call        _printf (0D9139Dh)  
00D91908  add         esp,4 
// 堆栈平衡
00D9190B  xor         eax,eax  
00D9190D  pop         edi  
00D9190E  pop         esi  
00D9190F  pop         ebx  
00D91910  add         esp,0CCh  
00D91916  cmp         ebp,esp  
00D91918  call        __RTC_CheckEsp (0D9122Bh)  
00D9191D  mov         esp,ebp  
00D9191F  pop         ebp  
00D91920  ret  
```

从汇编代码可以看出，当`if-else`在执行时，如果当前条件不相等，则会跳到下一个比较语句，所以如果 `a>1`的情况，这时候会先和`0、1`相比，这样在极端情况下，其实就多浪费了几条汇编语句，所以在使用`if-else`时，精良在多命中的条件写在前面。

## switch

```c++
switch (a) {
	case 0:
		printf("s 1");
		break;
	case 1:
		printf("s 1");
		break;
	case 2:
		printf("s 1");
		break;
	default:
		printf("s other");
	}
```

这里需要注意的是，如果条件太少，编译器可能会优化为类似`if-else`的情况，具体个数看具体编译器。

````assembly
// int a =5
001A4EDD  mov         dword ptr [a],5  
// 下面一堆都是计算 该跳转到哪
001A4EE4  mov         eax,dword ptr [a]  
001A4EE7  mov         dword ptr [ebp-0D0h],eax  
001A4EED  cmp         dword ptr [ebp-0D0h],5  
001A4EF4  ja          $LN9+0Fh (01A4F5Dh)  
001A4EF6  mov         ecx,dword ptr [ebp-0D0h]  
001A4EFC  jmp         dword ptr [ecx*4+1A4F80h]  

// 一个case语句
001A4F03  push        offset string "s 1" (01A7BCCh)  
001A4F08  call        _printf (01A139Dh)  
001A4F0D  add         esp,4  
001A4F10  jmp         $LN9+1Ch (01A4F6Ah)  

// default的情况
001A4F5D  push        offset string "s other" (01A7BD0h)  
001A4F62  call        _printf (01A139Dh)  
001A4F67  add         esp,4 
````

从汇编代码看出，`switch`与`if-else`最大的不同是，`switch`是会先计算跳转位置，计算完成后，直接跳转到对应的`case`语句直接执行，不用像`if-else`那样需要一个条件一个条件判断。