# 什么是STW

不管是新生代或者老年代，在垃圾回收时都会遇到一个问题，就是stw(stop the world)，也就是在清理虚拟机垃圾时，会暂停虚拟机的业务线程，这样导致结果是：`系统卡顿`。

假设一次新生代回收时20ms，那么在这20ms内，系统是无法对用户的请求进行处理。



# 新生代GC

新生代GC一般不会造成太长的stw，所以对性能的影响不会太大，毕竟一般新生代都是采用的复制算法，复制算法是非常高效，同时Eden中存活对象比较少。需要移动到survivor中的对象不多。

一般来说对新生代调优一般核心在于堆内存的分配，如果新生代分配合理，一般几小时才有一次GC，高分期也就几分钟一次。

**什么时候新生代GC对系统影响大？**

一般来说在大内存机器上时，JVM分配几十个G内存时，这时候新生代有10个G的内存。这时候遇到Kafka等这种大数据量相关的系统，每秒几万访问请求，导致你的Eden可能只需要很短的时候就塞满了，但是由于Eden太大了，清理一次需要可能几秒钟。这样导致每隔一两分钟就会卡几秒钟，在高并发时，一旦卡死几秒钟会导致你系统报错。

**过慢解决**

使用G1收集器，设置一个`预期的每次GC停顿时间`,比如设置一个20ms，

这样G1根据他的评估，会对满足配置的情况下进行垃圾回收，同时仅仅停顿20ms，当然并不是不停顿了，而是吧几秒拆分成了n个20ms，同时G1考虑的GC效率，这样更高效。

所以G1很适合这种大内存机器的JVM。

# 老年代GC

老年代GC通常来说很耗费时间，无论是CMS还是G1，因为CMS要经历初始标记、并发标记、重新标记、并发清理、碎片整理等。

一般进入老年代的有三种情况：

1. 对象年龄太大，这样的对象一般不多，基本都是静态变量，这种也不需要进行GC回收。
2. 动态年龄判断：如果一次新生代GC后，发现survivor区域中的几个年龄的对象加起来超过survivor中的50%，比如年龄1+年龄2+年龄3的对象综合超过了survivor的50%，此时就会把年龄3以上的对象都放入老年代。
3. 新生代垃圾回收过后，存活对象太多了，无法放入survivor中在，此时直接进入老年代。

一般来说如果你的survivor区域过小，会导致第二和第三频繁发生，导致大量独享进入老年代，进而频繁触发老年代GC。

一旦JVM内存分配不合理，就会频繁进行老年代GC，比如几分钟进行一次老年代GC，导致系统停顿几秒钟，那对于系统来说是致命。



# 总结

JVM性能优化，最大的问题就是 因为内存分配、参数设置不合理，导致你的 对象频繁进入老年代，然后频繁发生老年代GC。