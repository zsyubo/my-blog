# 核心

优化思路总的来说就一句话：`每次让Young GC后存活的对象小于Survivor区域的50%，都留在年轻代中。劲量不让对象进入老年代，这样减少Full GC的频率，避免频繁Full GC对JVM性能的影响。`

# 压测

如何找到系统问题点了？很多时候我们直接看代码看不出个所以然的，我们一般是根据老大定的大概的性能指标，然后进行压力测试，一般压力测试做的好的话，很容易找出整理性能瓶颈，在压测几个小时或者几天后，如果Yong GC和Full GC频率都很低，此时就可以部署系统上线了。

# 监控

一般full gc10分钟超过3次就要发邮件了。

# 排查思路

一般遇到JVM出问题都是Full GC过多，所以在线上时，我们需要收集JVM GC信息，方式很多，也有很多公司有自己的GC报警工具，出现问题，一般会如下步骤：

1. 监控GC频率
2. 找出导致对象大批量进入老年代的原因，一般有3种情况：每次存活对象过多(超过50%)、15次回收后存活的对象过多、大对象。

# 系统卡死

一般有2个原因

1. 创建线程过多
2. Full GC太频繁

# Full GC频繁原因

大多为以下原因

1. 内存分配不合理，导致对象频繁进入老年代
2. 存在内存泄露等问题，就是老年代有大量对象，导致稍微有一些对象进入老年代就引发full GC。
3. 永久代里的类太多，触发了full GC。

**查找原因**

full GC 一般都是老年代对象太多导致，这时候我们就可以去看下到底是什么对象过多，可以使用jmap+jhat的组合来分析内存里的对象，当然mat工具也可以。