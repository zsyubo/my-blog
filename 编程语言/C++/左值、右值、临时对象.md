# # 左值
```
int i = 10;
i =20;
```
能用在赋值语句等号左侧的东西，它代表一个地址、一个有名称的变量。
左值有时可以当右值使用,如下，i是左值(只是有右值属性)。
```
i = i + 1;
```
# # 左值引用
1. 左值引用
2. const引用(常量引用)右值引用(绑定到右值)
```
const int &refval2 = 3;
```
# # 右值
不为作为左值的就是右值；右值不能出现在等号左侧，也可以简单理解为`即将作废的对象`。右值引用不能绑定到左值上。

`右值指的是数据本身，不能取到其自身地址，右值只能赋值运算右边`

1. 右值引用(绑定到右值), 可以用来绑定一些即将销毁、临时的变量。
```
// &&  C++11引入
int &&refvalue = 3;
refvalue  = 6;
```
# # 右值引用
todo
# # 左值、右值、临时变量
有一些特殊情况

```
string strtest{"asd"};// asd其实就是一个临时变量，可以看做右值。
string &st1{"asd"};// 不可以，左值引用不能绑定到临时变量上
const  string &st2{"asd"};// 可以。
string &&s3{“asd”};// 可以，绑定一个临时变量。
```
算术运算符也会生成右值
```
int i  =10;
int &r1 =i;
int  &&r3 = i* 100;// 算术运算符生成临时右值。
int &r4 = i*100;// 编译失败，左值引用无法绑定到右值。
```
左值引用的函数、左值赋值、下标、解引用、前置递增递减运算符(--i) 都是返回左值。
非引用的函数、算术、关系、位、以及后置递增运算符（i--）都生成右值。

# # std::move 函数
是C++11的新语言特性，唯一功能是将一个左值引用转化为右值引用，继而通过右值引用使用该值。

std::move是将对象的对象或所有权从一个独享转移到另一个独享，只有转移，并不涉及到内存的拷贝或搬移，所以可以提高效率，改善性能，当然`不能滥用`。

**案例：字符串拷贝**

````c++
string("bert");
string name(std::move(tmp));
````

优点是直接进行把`bert`的所有权移交给了name，这要省去了拷贝，性能更高。缺点是：移动了后，tmp已经处于一种无效状态，不应该继续使用tmp了。

**注意**

并不是任何场合都适合用move，因为现代编译器足够聪明，自己会做0优化，特别是能够执行RVO优化(返回值优化)的地方，不要加std::move.

```c++
// 代码示例
std::string MakeName(const std::string& prefix) {
    std::string name(prefix);
    name += ".txt";
    return name; // RVO优化
    //return std::move(name); 如果你画蛇添足使用了这行代码，反而防止了编译器优化，带来一次move constructor的开销
}

// 由于RVO优化，函数内局部变量name直接在n上构建。
std::string n = MakeName("hello");
```

![](https://doc.shiyanlou.com/courses/uid18510-20190620-1561017797689)



只有一个目的，将一个左值强制转为右值。c++11引入。

```
int i = 10;
int &&r1 = std::move(i);// 执行了move之后，尽量不再对i进行操作。
```
# #  临时对象
产生临时对象的3种情况：
1. 以值得方式给函数传递参数。
