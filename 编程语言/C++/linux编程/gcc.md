#什么是GCC

GNU C Compiler的缩写，当然不只支持C，还支持C++。

编译c++ 也可以使用g++命令。

# 编译示例

编译源码代码，并吧可执行文件命名为hello。

```shell
gcc -o hello hello.c
```

如果需要使用gcc编译C++程序，需要带上`-lstdc++`, 指定使用C++库。

**编译多个类**

```shell
gcc hello.cpp speak.cpp -o hello  -lstdc++
g++ hello.cpp speak.cpp -o hello
```

当然嫌麻烦可以直接使用

```shell
gcc *.cpp speak.cpp -o hello  -lstdc++
g++ *.cpp speak.cpp -o hello
```

当然，缺点也是有点，在大型项目中，全部编译一次需要几十分钟甚至更久，那么我不能修改一部分文件全部编译一次，也不可能手动一个个把修改过的编译一次，所以我们需要`makefile`，不过不在本次内容中。

# 编译选项

| 选  项                 | 功  能                                                       |
| ---------------------- | ------------------------------------------------------------ |
| -c                     | 只激活预处理、编译和汇编,生成.o 目标代码文件                 |
| -S                     | 只激活预处理和编译，生成扩展名为.s的汇编代码文件             |
| -E                     | 只激活预处理，并将结果输出至标准输出                         |
| -g                     | 为调试程序(如gdb)生成相关信息                                |
| -O                     | 等同-O1,常用的编译优化选项                                   |
| -Wall                  | 打开一些很有用的警告选项，建议编译时加此选项。               |
| -pipe                  | 加快编译的速度，节约时间                                     |
| -o                     | 多文件编译时，输出的可执行文件名                             |
| **-l**(小写的I)        | 用于指定程序要链接的库，-l后面紧接着（没有空格）就是库名xxxx(去掉lib和.so) |
| **-L**(大写的   L)     | 如果libxxxx.so没有放在默认的路径下(/lib ,/usr/lib, /usr/local/lib), 旧需要制定 so库的路径。假设libxxxx.so所在目录为/aa/bb/cc，那么使用格式如下：-L/aa/bb/cc –lxxxx |
| **-I** ( **i** 的大写) | 指定头文件路径（相对路径或觉得路径，建议相对路径）           |
| **-i**                 | 指定头文件名字 (一般不使用，而是直接放在**.c 文件中通过#include<*.h> **添加) |

 `注意：`-c选项在编写大型程序是必须的，多个文件的源码首先需要编译成目标目标代码。在连接成执行文件。

**编译优化**

GCC选项提供了三个级别的优化选项：O1、O2、O3，理论上 `-O3`选项可以生成执行效率最高的代码，但有着更大的风险，通常-O1 、-O2就可以满足绝大多数需求。如Nginx编译就采用-O1。

- O1: 优化编译需要更多时间，并且大型函数需要更多内存。使用-O选项，编译器会尝试减小代码尺寸减少执行时间，不执行任何需要大量编译时间的优化。 
- -O2：相对-O优化更多。 GCC几乎执行所有支持的优化，但不涉及空速权衡。 与-O相比，此选项增加了编译时间和生成代码的性能。-O2除了打开所有-O指定的优化标志，还打开了如下优化标志：

# 动态库

**编译**

通过参数`-fPIC -shared`我们可以编译出动态库(so)

```makefile
gcc test_a.c test_b.c test_c.c -fPIC -shared -o libtest.so
```

当然，要需要注意路径的问题

**连接**

```makefile
gcc 需要连接的源文件 -L. -l动态库名 -o test

gcc test.c -L. -ltest -o test
```

<font color=red>`注意：`编译的so文件必须以lib开头，当进行链接是需要去掉这个lib</font>

```makefile
# 编译动态库
gcc  libxxx.so
# 链接动态库
gcc  -lxxx.so
```

# 编译静态库

todo