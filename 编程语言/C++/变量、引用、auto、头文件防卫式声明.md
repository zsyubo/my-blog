# 1. 变量
在c++中，局部变量及初始化可以做到随时定义、初始化。
## ## 新定义方式
```c++
int i{ 5 };
int i = { 5 };
// 数组可以这样定义
int a[]{ 11,12,35 };
```
有意思的地方
```
// 程序正常执行，但是 `.5f`会被系统截断。
int  ac = 3.5f
// 直接编译失败
int ac {3.5f}
```

## ## auto 变量的自动类型推断
可以在变量声明的时候根据变量的初始值的类型自动为此变量选择匹配的类型。当然啦，自动推断是发生在`编译期间`,所以既然要推断，`声明时就要赋予初始值`，可能编译时慢一点，但是好处是`运行时不会造成程序性能降低`。
```c++
 auto bb = true;
 auto cc { 1 };
```
## ## 头文件防卫式声明
有时候我们会在头文件中声明变量，但是一个cpp可能引入多个头文件，如果多个头文件都定义了一个相同名称的变量就会出现`重定义`的错误
例如
a.cpp
```c++
#include "h1.h"
#include "h2.h"
```
h1.h
```
int g = { 5 };
```
h2.h
```c++
#include "h1.h"
```
此时编译会报错，包重复定义这个错误，这时候就是头文件引入了多次的错误。解决方案如下：
```c++
// 如果没定义 PCH_H 则执行代码， 这样做防止头文件多重调用
#ifndef PCH_H
// 定义PCH_H ，
#define PCH_H
#endif //PCH_H
```
# 2. 引用
可以理解为：为变量启另一个名字，一般用&符号表示。起完别名后 ，这别名和变量可以看做是同一变量。`定义引用的时候必须初始化`,同时要与别引用的类型相同。底层其实并不是占的同一块内存。
```c++
 int value = 110;
// 注意这不是取地址，是引用。
 int &ref = value;
// 和普通变量一样使用
 cout << ref << endl;
```
**一般用于参数传递**

普通函数传参是传的值。

```c++
int main()
{
int a = 15; 
 int b = 61;
 func(a, b);
 cout << "a:" << a << "b:" << b << endl; // 4,5
}

void func(int &a, int &b) {
    // 在函数值中修改引用值，对原值有引用，相当于传了一个指针。但是比指针更安全，因为不能修改引用地址。
    int tt = a;
    a = b;
    b = tt;
}
```
> 引用是一个指向其它对象的常量指针，它保存着所指对象的存储地址。并且使用的时候会自动解引用，而不需要像使用指针一样显式提领。

**引用字面量**

不能创建对未命名值(例如整形字面量)的引用，除非是引用是一个const值。

```c++
int &unf =5 ; // 编译失败
const int& uuu= 6;// 编译成功
```

## 指针类型的引用

可以创建任意类型的引用，也包括指针。

```c++
    int *intP;
    int *& ptRef = intP;
    ptRef = new int{1};
    *ptRef = 5;
    cout << *ptRef<< endl; //5
```

其实引用所指向就是指针地址。`*(指针地址所指向的堆空间)`。`我们可以声明指向指针的引用，但是无法什么指向引用的指针`。

## 指针转换为引用

如果一个方法需要一个引用做参数，但是你拥有一个指向被传递值得指针，这是情景也不叫常见，这种情况下，可以对指针解除引用，将指针`转换`为引用。

```c++
  int *pa =&a;
  int *pb = &b;
  func(*pa, *pb);
```

## 引用的好处

1. 如果是按值传递，一些大一点的对象或结构需要较长的时间，引用只是传指针过去，更快。

2. 同时值传递会有深度复制的问题(比如：对象包对象的情况)。所以一般值传递只用于简单的内建类型(int、long等)。对象都应该采用引用传递。

3. 同时引用更安全，指针可能存在空指针、野指针的情况。但是引用不存在无效引用，也不需要显示的解除引用。`所以在不需要改变所指地址时，就引用使用引用而不是指针。`

# # nullptr  C++11 引入

用来表示空指针。和NULL类似，但类型不同。引入的目的主要是避免指针和整数的混淆(NULL 底层实际为0；并不是完全意义上的空值。)
在实际开发中，如果需要用到 `指针与NULL的场合，用nullptr来取代NULL`。

```
 char *p = NULL;
 char *q = nullptr;
```
区别
```
// 不会报错
 int a = NULL;
 // 语法报错
 //int b = nullptr;
```
蛋疼的地方
```
 if (p == nullptr)
 {
  cout << "NULL == nullptr" << endl;  
 }
 if (q == NULL )
 {
  cout << "nullptr == NULL" << endl;
 }

// NULL == nullptr
 //nullptr == NULL
```

`NULL和nullptr的类型不同`
```
 cout << typeid(NULL).name() << endl; //int
  cout << typeid(nullptr).name() << endl; // std::nullptr_t
```