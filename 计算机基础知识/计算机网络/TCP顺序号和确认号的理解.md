# 概念

TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收。

# 三次握手

![img](https://images0.cnblogs.com/blog2015/629726/201504/202017032776158.png)

我们只关注其中的`seq`和`ACK`，也就是序列号和确认号。

## Seq

seq是一个32bit的的序列号，初始序列号是一个 32 位的（虚拟）计数器，而且这个计数器每 4 微秒加 1，也就是说，ISN 的值**每 4.55 小时循环一次**。这个举措是为了**防止序列号重叠**。

但即使这样还是会有安全隐患——因为初始 ISN 仍然是可预测的，恶意程序可能会分析 ISN ，然后根据先前使用的 ISN **预测**后续 TCP 连接的 ISN，然后进行攻击，一个著名的例子就是「The Mitnick attack[^2](https://link.zhihu.com/?target=http%3A//wiki.cas.mcmaster.ca/index.php/The_Mitnick_attack)」 。

所以初始的序列号并非从 0 开始，通信双方各自生成，一般情况下两端生成的序列号不会相同。生成的算法是 ISN 随时间而变化，会递增的分配给后续的 TCP 连接的 ISN。

**注意：**wireshark我们看到的ISN为0只是wireshark为了方便理解而展示的相对序列号(真实的都很长)，不是真是的ISN。

**为什么 SYN 段不携带数据却要消耗一个序列号呢？**

并不是没有数据，其实里面的`SYN=1`就是要发送的数据，SYN  端虽然没有携带数据，`但是因为 SYN 段需要被确认，所以它也要消耗一个序列号`



# 参考资料

[TCP 的三次握手，四次挥手和重要的细节—干货满满，建议细读](https://zhuanlan.zhihu.com/p/96568756)